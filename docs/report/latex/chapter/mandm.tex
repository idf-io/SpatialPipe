\chapter{Material and Methods}


\textbf{Dataset.} The publically available MIBI-TOF colorectal cancer dataset from \cite{Hartmann-2021} spans 58 images of 4 donors. 40 samples belong to 2 donors which were diagnosed with the colorectal carcinoma. Both cancerous colon and healthy adjacent tissue were included. The remaining 18 samples belonged to 2 donors with healthy colon. The images measure 36 protein levels across $400 \mu m^2$ and 1024 bins\textsuperscript{2}. 63747 cells were measured int total across all images. The data had been previously pre-processed by the authors. It had undergone noise removal, cell-size normalization, arcsinh transformation and percentile normalization. The authors also provided the segmentation masks, which were calculated via a watershed-coupled convolutional neural network trained on different cancer types.The provided cell-type annotation was obtained via FlowSOM clustering and manual annotation based on main cell-lineage markers. Included cell types were: endothelial, epithelial cells, fibroblasts, other CD45\textsuperscript{+} immune cells, CD68\textsuperscript{+} myeloid cells, CD68\textsuperscript{+} myeloid cells, CD4\textsuperscript{+} T-cells and CD8\textsuperscript{+} T-cells. Major lineage markers were defined by the authors: CD11c, CD14, CD3, CD31, CD4, CD45, CD68, CD8, smooth muscle actin (SMA), E-cadherin (Ecad), cytokeratin (CK) and vimentin.

\textbf{Visualization.} Segmentation, scatter plots and raw expression images were generated by loading the expression data and image channels into an `anndata.AnnData()` class from the `Anndata` module and using the `Squidpy` module and loading the expression data, metadata. PCA and UMAP embedding were generated using the `Scanpy` module. The cell-type frequency distribution plots were generated with the `matplotlib.pyplot` module.

\textbf{Unsupervised analysis.} PCA dimensionality reduction and neighbourhood graph were calculated using the `Scanpy` module with default settings. UMAP embedding was also calculated via the `Scanpy` module and the top 10 ranked  principal components. The latter number was chosen based on the elbow plots of accounted variance of ranked principal components. Highly variable genes were calculated using the `scanpy.pp.highly\_variable\_genes()` function.

\textbf{Spatial connectivity graph.} The spatial graph was generated using the `Squidpy` package. The coordinate type was set to "generic" (coord\_type) and the neighbourhood was set to include all cells within a 35 px (~14 Âµm) radius.

\textbf{Spatial distribution statistics of cell-type annotation.} The Ripley's L statistic, clustering coefficients (centrality score statistic), neighbourhood enrichment analysis and co-occurence analysis were obtained using the `Squidpy` package using default parameters.

\textbf{Spatial feature distribution statistic.} The Moran's L statistic was calculated using the `Squidpy` package. The mode was set to "Moran" and  permutations (n\_perms) were set to 100.

\textbf{Linear NCEM.}  Linear NCEM model was applied using its publically available python module. The linear NCEM model is a simple linear regression: $\hat{Y} = X^D \beta$ where $\hat{Y} \in \mathbb{R}^{N \times J}$ where N are the number of cells and J is the number of features. The design matrix  $X^D \in \mathbb{R}^{N \times (L \textsuperscript{+} L^2 \textsuperscript{+} C)}$, where C is the batch assignment, is constructed using the concatenation of the one-hot encoding of the index cell type, the one hot encoded presence (0 or 1) of each cell type in the radius-based constructed neighbourhood graph and the batch assignment (interaction terms as combinatorial and directional cell-type labels). The covariate matrix $\beta \in \mathbb{R}^{(L \textsuperscript{+} L^2 \textsuperscript{+} C) \times J}$ is learned via ordinary least squares loss function. To train, validate and test the model, the tutorial provided by the author's was followed \url{https://github.com/theislab/ncem_tutorials}. The same parameters were used with exception of dataset specific arguments. The data was loaded using the `DataLoaderHartmann()` class via setting the `data\_origin='hartmann'` parameter when running the `get\_data()` function on the `ncem.estimators.EstimatorInteractions` class. The `radius` was set to 35 px which the author had shown to yield the best predicitve performance. The `batch\_size` was set to 58. The dataset was split to 80\% training, 10\% validation and 10\% testing sets. Evaluation outputs several statistics including the loss, gaussian reconstruction loss and $R^2$ value.


\textbf{Linear NCEM sender-receiver effects.} The linear interactions tutorial from the author's tutorial github repository \url{https://github.com/theislab/ncem_tutorials/} was followed. The data was loaded using the `DataLoaderHartmann()` class via setting the `data\_origin='hartmann` parameter when running the `get\_data()` function on the `ncem.estimators.EstimatorInteractions` class. The radius parameter was set to 35 px which was observed to yield the best predictive performance in the grid search. Observation data was split into training (90\%), validation (10\%) and test (10\%) sets. 10 nodes per graph were used for hyperparameter tuning. After applying the `ncem.estimators.EstimatorInteractions.get\_sender\_receiver\_effects()` function, NCEM output two relevant tensors (1) the interaction term values tensor $I \in \mathbb{R}^{L \times L \times J}$ where L are the cell-type labels and J the features (dimensions: receiver-cell-type x sender-cell-type x features ) and (2) the p-values tensor of the Wald test applied to the interaction terms, FDR-corrected via the Benjamini-Hochberg correction (q-values). The former represents the effect of individual features of a sender cell-type on a receiver cell-type. Next, the the first summary statistic was calculated inspired by the `type\_coupling\_analysis()` approach of the package authors. The number of statistically significant features were quantified per sender-receiver label pairs via the L1-norm. Alpha-level value 0.05 was used to set the significance threshold. The second summary statistic approach, deviating from the author's approach, calculated the L2-norm of the feature axis per sender-receiver cell-type pairs. Both summary statistic matrices are of (sender-cell-type x receiver-cell-type) dimensionality. A wrapper was written to make the application to these approaches easier on the end user. The wrapper allows to set the radius, number of evaluated nodes, alpha-level values for FDR corrected significance threshold and end-value-level thresholds for both approaches. The former parameter can also be set using a quantile threshold for the second approach. Exclusively for the second approach, a range-threshold for the raw interaction terms can be set (hard range or standard-deviation-based).

\textbf{NCEM cell-type annotation shuffling analysis.} To simulate upstream artifacts like imperfect segmentation or wrong cell-type annotation, the provided cell-type annotations were shuffled in different fractions (0%, 0.1%. 1%, 10%, 50% and 100%) of randomly selected cells. Afterwards, the linear NCEM model was applied as described in (Methods: linear NCEM). The process was repeated 15 times for every fraction percentage to generate a distribution of explained variance values ($R^2$).

\textbf{MISTy.} `MISTy` was applied using the public R package on the author's github repository. In the case of this study, a single "para-view" was defined as the weighted sum of the feature values across all cells within a 35 px `radius`. The weighting was set to a gaussian kernel (`family='gaussian`) and the learnable function (`model.function`) is left as per default to random forest. The input were the spatial positions and feature expression. MISTy outputs three types of data (1) the improvement of explained variance ($R^2$) via contrasting the application of the model with solely the "intra-view" and the application of the model using both the "multi-view" model ("intra-" and "para-view" considered) on a feature-level, (2) the learnable weight parameters of the metamodel which represent the "view-effect" and (3) the interactions or importances that each predictor feature contributes to the target feature via leave-one-out procedure. The latter output is calculated on a per-view basis which is then subtracted to create the importances contrast heatmap. Image points 1, 4, 10, 13, 17, 18, 19, 20, 30, 32, 34, 50 and 52 were excluded.

\textbf{Customized MISTy workflow.} The standard MISTy workflow (Methods: MISTy) was modified to use as input the one-hot encoding of the index cell-type instead of the feature space. The "intra-view" was bypassed. The "para-view" definition was changed to use a constant kernel.
